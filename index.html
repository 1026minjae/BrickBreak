<!DOCTYPE html5>

<html>

<head>
<title>BrickBreak</title>
<meta charset="utf-8" />

<style>
body {
    display: grid;
    place-items: center;
}
canvas {
    border: 1px black solid;
}
</style>

<script>
const BRICK_WIDTH = 100;
const BRICK_HEIGHT = 50;

const BALL_RADIUS = 5;
const BALL_SPEED = 10;
const GAP_BETWEEN_BALLS = 4;

const ARROW_LENGTH = 100;

const BOARD_ROW_MAX = 10;
const BOARD_COLUMN_MAX = 6;
const BOARD_WIDTH = BRICK_WIDTH * BOARD_COLUMN_MAX;
const BOARD_HEIGHT = BRICK_HEIGHT * (BOARD_ROW_MAX + 5);
const ORIGIN_X = Math.floor(BOARD_WIDTH / 2);
const ORIGIN_Y = BOARD_HEIGHT - BRICK_HEIGHT;

const BOARD_BRICKAREA_BOTTOM_Y = BOARD_HEIGHT - BRICK_HEIGHT * (BOARD_ROW_MAX + 1);
const BOARD_LEFT_WALL_X = ORIGIN_X;
const BOARD_RIGHT_WALL_X = -ORIGIN_X;
const BOARD_TOP_WALL_Y = ORIGIN_Y;
const BOARD_BOTTOM_WALL_Y = ORIGIN_Y - BOARD_HEIGHT;

class Ball {
    constructor (x, y, vx, vy) {
        this.X = x;
        this.Y = y;
        this.velocityX = vx;
        this.velocityY = vy;
    }

    move () {
        this.X += this.velocityX;
        this.Y += this.velocityY;
    }

    checkIfCollidedToWallThenReverseDirection () {
        if (this.X >= BOARD_LEFT_WALL_X - BALL_RADIUS) this.velocityX *= -1;
        else if (this.X <= BOARD_RIGHT_WALL_X + BALL_RADIUS) this.velocityX *= -1;
        else if (this.Y >= BOARD_TOP_WALL_Y - BALL_RADIUS) this.velocityY *= -1;
        else return false;

        return true;
    }

    checkIfCollidedToGivenBrickThenReverseDirection (rowIdx, colIdx) {
        let brickRightX = BOARD_RIGHT_WALL_X + colIdx * BRICK_WIDTH;
        let brickLeftX = brickRightX + BRICK_WIDTH;
        let brickBottomY = BOARD_BRICKAREA_BOTTOM_Y + rowIdx * BRICK_HEIGHT;
        let brickTopY = brickBottomY + BRICK_HEIGHT;

        // todo
        if ((this.X <= brickLeftX + BALL_RADIUS) && (this.X > brickLeftX) &&
           (this.Y <= brickTopY) && (this.Y >= brickBottomY)) { // ball hits left side of brick
            this.velocityX *= -1;
        }
        else if ((this.X >= brickRightX - BALL_RADIUS) && (this.X < brickRightX) &&
           (this.Y <= brickTopY) && (this.Y >= brickBottomY)) { // ball hits right side of brick
            this.velocityX *= -1;
        }
        else if ((this.Y <= brickTopY + BALL_RADIUS) && (this.Y > brickTopY) &&
           (this.X <= brickRightX) && (this.Y >= brickLeftX)) { // ball hits top side of brick
            this.velocityY *= -1;
        }
        else if ((this.Y >= brickBottomY - BALL_RADIUS) && (this.Y < brickBottomY) &&
           (this.X <= brickRightX) && (this.X >= brickLeftX)) { // ball hits bottom side of brick
            this.velocityY *= -1;
        }
        else return false;

        return true;
    }

    isActive () {
        return (this.Y >= 0 || this.velocityY > 0);
    }

    isNotShot () {
        return (this.Y < 0);
    }
}

let ballCnt = 0;
let activeBallList = [];
let brickData;

let ctx;
let timer;

window.onload = () => {
    initUI();
    initBrickData();
    initGame();
};

function initUI () {
    let board = document.createElement("canvas");
    board.setAttribute("width", BOARD_WIDTH.toString() + "px");
    board.setAttribute("height", BOARD_HEIGHT.toString() + "px");
    board.addEventListener("mousemove", boardMouseMove);
    board.addEventListener("click", boardClick);
    document.querySelector("body").appendChild(board);

    ctx = board.getContext("2d");
    ctx.translate(ORIGIN_X, ORIGIN_Y);
    ctx.rotate(Math.PI);
    ctx.font = "20px bold serif";
}

function initBrickData () {
    brickData = new Array(BOARD_ROW_MAX);
    for (let rowIdx = 0; rowIdx < BOARD_ROW_MAX; ++rowIdx) {
        brickData[rowIdx] = new Array(BOARD_COLUMN_MAX);
        for (let colIdx = 0; colIdx < BOARD_COLUMN_MAX; ++colIdx) {
            brickData[rowIdx][colIdx] = 0;
        }
    }
}

function initGame () {    
    addNewBall();
    addNewBall();
    addNewBall();

    addNewBrick();
    addNewBrick();
    addNewBrick();

    drawBricks();
    aimModeProcedure(0, 1);
}

function addNewBall () {
    ballCnt += 1;
}

function addNewBrick () {
    let randomRow;
    let randomColumn;

    do {
        randomRow = Math.floor(Math.random() * BOARD_ROW_MAX);
        randomColumn = Math.floor(Math.random() * BOARD_COLUMN_MAX); 
    } while (brickData[randomRow][randomColumn] !== 0);
    
    brickData[randomRow][randomColumn] = 1;
}

function boardMouseMove (e) {
    let translatedX = ORIGIN_X - e.offsetX;
    let translatedY =Math.max(ORIGIN_Y - e.offsetY, 0);

    aimModeProcedure(translatedX, translatedY);
}

function aimModeProcedure (targetX, targetY) {
    clearAreaOfArrow();
    drawArrowTowards(targetX, targetY);
    drawBaseline();
    drawBallCntTxt();
}

function clearAreaOfArrow () {
    ctx.clearRect(BOARD_RIGHT_WALL_X, 
                    BOARD_BOTTOM_WALL_Y, 
                    BOARD_WIDTH, 
                    ARROW_LENGTH - BOARD_BOTTOM_WALL_Y + 1);
}

function drawArrowTowards (x, y) {
    ctx.save();

    ctx.rotate(Math.atan(-x / y));
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, ARROW_LENGTH);
    ctx.lineTo(ARROW_LENGTH * 0.02, ARROW_LENGTH * 0.9);
    ctx.lineTo(ARROW_LENGTH * -0.02, ARROW_LENGTH * 0.9);
    ctx.lineTo(0, ARROW_LENGTH);
    ctx.moveTo(0, 0);
    ctx.stroke();

    ctx.restore();

    ctx.arc(0, 0, BALL_RADIUS, Math.PI * 2, 0);
    ctx.fill();
}

function drawBaseline () {
    ctx.beginPath();
    ctx.moveTo(BOARD_LEFT_WALL_X, 0);
    ctx.lineTo(BOARD_RIGHT_WALL_X, 0);
    ctx.stroke();
}

function drawBallCntTxt () {
    ctx.rotate(Math.PI);
    ctx.fillText(ballCnt.toString(), BOARD_RIGHT_WALL_X + 5, -5);
    ctx.rotate(Math.PI);
}

function boardClick (e) {
    let translatedX = ORIGIN_X - e.offsetX;
    let translatedY = ORIGIN_Y - e.offsetY;

    switchToCollideMode(translatedX, translatedY);
}

function switchToCollideMode (targetX, targetY) {
    let board = document.querySelector("canvas");
    board.removeEventListener("mousemove", boardMouseMove);
    board.removeEventListener("click", boardClick);

    arrangeBalls(targetX, targetY);

    timer = setInterval(collideModeProcedure, 20);
}

function arrangeBalls (targetX, targetY) {
    let distance = Math.sqrt((targetX * targetX) + (targetY * targetY));
    let velocityX = targetX / distance * BALL_SPEED;
    let velocityY = targetY / distance * BALL_SPEED;
    let gapX = -GAP_BETWEEN_BALLS * velocityX;
    let gapY = -GAP_BETWEEN_BALLS * velocityY;

    for (let i = 0; i < ballCnt; ++i) {
        let newBall = new Ball(i * gapX, i * gapY, velocityX, velocityY);
        activeBallList.push(newBall);
    }
}

function collideModeProcedure () {
    clearBoard();
    moveAndCollideBalls();
    removeInactiveBalls();

    if (activeBallList.length === 0) switchToAimMode();

    drawBalls();
    drawBricks();
    drawBaseline();
    drawBallCntTxt();
}

function clearBoard () {
    ctx.clearRect(BOARD_RIGHT_WALL_X, 
                    BOARD_BOTTOM_WALL_Y, 
                    BOARD_WIDTH, 
                    BOARD_HEIGHT);
}

function moveAndCollideBalls () {
    activeBallList.forEach((ball) => {
        ball.move();
        ball.checkIfCollidedToWallThenReverseDirection();
        for (let rowIdx = 0; rowIdx < BOARD_ROW_MAX; ++rowIdx) {
            for (let colIdx = 0; colIdx < BOARD_COLUMN_MAX; ++colIdx) {
                if (brickData[rowIdx][colIdx] !== 0 && 
                   ball.checkIfCollidedToGivenBrickThenReverseDirection(rowIdx, colIdx)) {
                    brickData[rowIdx][colIdx] -= 1;
                }
            }
        }
    });
}

function removeInactiveBalls () {
    activeBallList = activeBallList.filter((ball) => {
        return ball.isActive();
    });
}

function drawBalls () {
    activeBallList.forEach((ball) => {
        if (ball.isNotShot()) return; 
        ctx.beginPath();
        ctx.arc(Math.floor(ball.X), Math.floor(ball.Y), BALL_RADIUS, Math.PI * 2, 0);
        ctx.fill();
    });
}

function drawBricks () {
    ctx.save();
    ctx.rotate(Math.PI);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (let rowIdx = 0; rowIdx < BOARD_ROW_MAX; ++rowIdx) {
        for (let colIdx = 0; colIdx < BOARD_COLUMN_MAX; ++colIdx) {
            if (brickData[rowIdx][colIdx] !== 0) {
                ctx.fillRect((BOARD_LEFT_WALL_X - (colIdx + 1) * BRICK_WIDTH), 
                             (-BOARD_BRICKAREA_BOTTOM_Y - (rowIdx + 1) * BRICK_HEIGHT), 
                             BRICK_WIDTH, BRICK_HEIGHT);
                ctx.fillStyle = "white";
                ctx.fillText(brickData[rowIdx][colIdx].toString(), 
                             (BOARD_LEFT_WALL_X - Math.floor((colIdx + 0.5) * BRICK_WIDTH)),
                             (-BOARD_BRICKAREA_BOTTOM_Y - Math.floor((rowIdx + 0.5) * BRICK_HEIGHT)),
                             BRICK_WIDTH);
                ctx.fillStyle = "black";
            }
        }
    }

    ctx.restore();
}

function switchToAimMode () {
    clearInterval(timer);

    let board = document.querySelector("canvas");
    board.addEventListener("mousemove", boardMouseMove);
    board.addEventListener("click", boardClick);

    aimModeProcedure(0, 1);
}
</script>
</head>

<body>
</body>

</html>
